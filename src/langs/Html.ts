// Html.ts

import { lodash, getPrettier } from "@exportLibs";
import type { PrettierOptions } from "@exportLibs";
import { htmlMinify, strip } from "@exportLibs";
import type { StripOptions } from "@exportLibs";
import { logger, notify, modal } from "@exportScripts";
import { CommonType } from "@exportTypes";

// 0. removeComments -------------------------------------------------------------------------------
export const removeComments = async (
	contentsParam: string,
	fileTabSize: number,
	fileEol: string,
	fileExt: string
) => {
	try {
		// 1. `http://` -> `httpp`
		const pattern1 = (
			/("|')(\s*)(http:\/\/)([\n\s\S]*?)("|')/gm
		);
		const pattern2 = (
			/("|')(\s*)(https:\/\/)([\n\s\S]*?)("|')/gm
		);
		const pattern3 = (
			/("|')(\s*)(@\{http:\/\/)([\n\s\S]*?)("|')/gm
		);
		const pattern4 = (
			/("|')(\s*)(@\{https:\/\/)([\n\s\S]*?)("|')/gm
		);

		const httpResult = lodash.chain(contentsParam)
			.replace(pattern1, (...p: unknown[]) => (
				`${p[1]}${p[2]}httpp${p[4]}${p[5]}`
			))
			.replace(pattern2, (...p: unknown[]) => (
				`${p[1]}${p[2]}httpps${p[4]}${p[5]}`
			))
			.replace(pattern3, (...p: unknown[]) => (
				`${p[1]}${p[2]}@{httpp${p[4]}${p[5]}`
			))
			.replace(pattern4, (...p: unknown[]) => (
				`${p[1]}${p[2]}@{httpps${p[4]}${p[5]}`
			))
			.value();

		const minifyResult = (
			await htmlMinify(httpResult, {
				html5: true,
				minifyCSS: false,
				minifyJS: false,
				minifyURLs: false,
				removeComments: true,
				removeAttributeQuotes: false,
				removeEmptyAttributes: true,
				removeEmptyElements: false,
				removeOptionalTags: false,
				removeRedundantAttributes: false,
				removeTagWhitespace: false,
				keepClosingSlash: true,
				includeAutoGeneratedTags: false,
				maxLineLength: 0,
				noNewlinesBeforeTagClose: false,
				trimCustomFragments: false,
				removeStyleLinkTypeAttributes: true,
				removeScriptTypeAttributes: true,
				caseSensitive: true,
				useShortDoctype: true,
				collapseBooleanAttributes: false,
				decodeEntities: true,
				collapseWhitespace: true,
				collapseInlineTagWhitespace: true,
				preserveLineBreaks: true,
				conservativeCollapse: true,
				preventAttributesEscaping: true,
				quoteCharacter: `"`,
				sortClassName: true,
				sortAttributes: true,
				continueOnParseError: true,
				processScripts: [],
				processConditionalComments: false,
			})
		);

		const baseOptions1: StripOptions = {
			language: `html`,
			preserveNewlines: false,
			keepProtected: false,
			block: true,
			line: true,
		};
		const baseOptions2: StripOptions = {
			language: `javascript`,
			preserveNewlines: false,
			keepProtected: false,
			block: true,
			line: true,
		};
		const baseOptions3: StripOptions = {
			language: `css`,
			preserveNewlines: false,
			keepProtected: false,
			block: true,
			line: true,
		};

		const stripResult1 = strip(
			minifyResult,
			baseOptions1
		);
		const stripResult2 = strip(
			stripResult1,
			baseOptions2
		);
		const stripResult3 = strip(
			stripResult2,
			baseOptions3
		);

		// 2. `httpp` -> `http://`
		const pattern1Re = (
			/("|')(\s*)(httpp)([\n\s\S]*?)("|')/gm
		);
		const pattern2Re = (
			/("|')(\s*)(httpps)([\n\s\S]*?)("|')/gm
		);
		const pattern3Re = (
			/("|')(\s*)(@\{httpp)([\n\s\S]*?)("|')/gm
		);
		const pattern4Re = (
			/("|')(\s*)(@\{httpps)([\n\s\S]*?)("|')/gm
		);
		const pattern5 = (
			/(\n)(\s*)(\n)/gm
		);

		const finalResult = lodash.chain(stripResult3)
			.replace(pattern1Re, (...p: unknown[]) => (
				`${p[1]}${p[2]}http://${p[4]}${p[5]}`
			))
			.replace(pattern2Re, (...p: unknown[]) => (
				`${p[1]}${p[2]}https://${p[4]}${p[5]}`
			))
			.replace(pattern3Re, (...p: unknown[]) => (
				`${p[1]}${p[2]}@{http://${p[4]}${p[5]}`
			))
			.replace(pattern4Re, (...p: unknown[]) => (
				`${p[1]}${p[2]}@{https://${p[4]}${p[5]}`
			))
			.replace(pattern5, (...p: unknown[]) => (
				`${p[1]}`
			))
			.value();

		logger(`debug`, `${fileExt}:removeComments - Y`);
		return finalResult;
	}
	catch (err: unknown) {
		logger(`error`, `${fileExt}:removeComments - ${(err as Error).message}`);
		return contentsParam;
	}
};

// 1. prettierFormat -------------------------------------------------------------------------------
export const prettierFormat = async (
	commonParam: CommonType,
	contentsParam: string,
	fileName: string,
	fileTabSize: number,
	fileEol: string,
	fileExt: string
) => {
	try {
		logger(`debug`, `${fileExt}:prettierFormat - start`);
		// 0. prettier
		const prettier = await getPrettier();
		const prettierStatus = prettier ? `prettier:loaded` : `prettier:missing`;
		logger(prettier ? `debug` : `warn`, `${fileExt}:prettierFormat - ${prettierStatus}`);

		// 1. parser
		const parser = `html`;

		// 2. plugin

		// 3. options
		const baseOptions: PrettierOptions = {
			parser: parser,
			singleQuote: commonParam.quoteType === `single`,
			printWidth: 1000,
			tabWidth: commonParam.tabSize,
			useTabs: true,
			quoteProps: `as-needed`,
			jsxSingleQuote: commonParam.quoteType === `single`,
			trailingComma: `all`,
			bracketSpacing: false,
			jsxBracketSameLine: false,
			arrowParens: `always`,
			rangeStart: 0,
			rangeEnd: Infinity,
			requirePragma: false,
			insertPragma: false,
			proseWrap: `preserve`,
			htmlWhitespaceSensitivity: `ignore`,
			vueIndentScriptAndStyle: true,
			endOfLine: fileEol === `lf` ? `lf` : `crlf`,
			embeddedLanguageFormatting: `auto`,
			singleAttributePerLine: false,
			bracketSameLine: false,
			semi: true,
			filepath: fileName,
			__embeddedInHtml: true,
		};

		const rules1 = (
			/(&nbsp;)/gm
		);
		const rules2 = (
			/(\s*)[^`'"](<.*>)(<)(input|label|a|b|p|span|select|div|option|bold|caption|strong)/gm
		);

		const result = lodash.chain(contentsParam)
			.replace(rules1, (...p: unknown[]) => (
				``
			))
			.replace(rules2, (...p: unknown[]) => (
				`${p[1]}${p[2]}\n${p[1]}\t${p[3]}${p[4]}`
			))
			.value();
		const formatterAvailable = prettier && typeof prettier.format === `function`;
		logger(formatterAvailable ? `debug` : `warn`, `${fileExt}:prettierFormat - ${formatterAvailable ? `formatter:ready` : `formatter:missing`}`);
		const finalResult = formatterAvailable
			? await (async () => {
				logger(`debug`, `${fileExt}:prettierFormat - format:start`);
				const formatted = await prettier.format(result, baseOptions);
				logger(`debug`, `${fileExt}:prettierFormat - format:success`);
				return formatted;
			})()
			: (() => {
					logger(`warn`, `${fileExt}:prettierFormat - format:skipped`);
					return contentsParam;
				})();
		logger(`debug`, `${fileExt}:prettierFormat - end`);
		return finalResult;
	}
	catch (err: unknown) {
		const msg = err.message.toString().trim().replace(/\x1B\[[0-9;]*[mGKF]/g, ``);
		const msgRegex = /([\n\s\S]*)(\s*)(https)(.*?)([(])(.*?)([)])([\n\s\S]*)/gm;
		const msgRegexReplace = `[Jlint]\n\nError Line = [ $6 ]\nError Site = $8`;
		const msgResult = msg.replace(msgRegex, msgRegexReplace);

		logger(`error`, `${fileExt}:prettierFormat - ${msgResult}`);
		modal(`error`, `${fileExt}: Prettier Format Error:\n${msgResult}`);
		return contentsParam;
	}
};

// 2. insertLine -----------------------------------------------------------------------------------
export const insertLine = async (
	contentsParam: string,
	fileExt: string
) => {
	try {
		const rules1 = (
			/^(?!\/\/--)(?:\n*)(\s*)([<]head\s*.*\s*[>])(\s*?)/gm
		);
		const rules2 = (
			/^(?!\/\/--)(?:\n*)(\s*)([<]body\s*.*\s*[>])(\s*?)/gm
		);
		const rules3 = (
			/^(?!\/\/--)(?:\n*)(\s*)([<]header\s*.*\s*[>])(\s*?)/gm
		);
		const rules4 = (
			/^(?!\/\/--)(?:\n*)(\s*)([<]main\s*.*\s*[>])(\s*?)/gm
		);
		const rules5 = (
			/^(?!\/\/--)(?:\n*)(\s*)([<]footer\s*.*\s*[>])(\s*?)/gm
		);
		const rules6 = (
			/^(?!\/\/--)(?:\n*)(\s*)([<]section\s*.*\s*[>])(\s*?)/gm
		);
		const rules7 = (
			/^(?!\/\/--)(?:\n*)(\s*)([<]table\s*.*\s*[>])(\s*?)/gm
		);
		const rules8 = (
			/^(?!\/\/--)(?:\n*)(\s*)([<]form\s*.*\s*[>])(\s*?)/gm
		);
		const rules9 = (
			/^(?!\/\/--)(?:\n*)(\s*)([<]div class="row\s*.*\s*[>])(\s*?)/gm
		);

		const finalResult = lodash.chain(contentsParam)
			.replace(rules1, (...p: unknown[]) => {
				const spaceSize = 100 - (p[1].length + `<!--`.length + `-`.length);
				const insetLine = `<!--${`-`.repeat(spaceSize)}-->`;
				return `\n${p[1]}${insetLine}\n${p[1]}${p[2]}${p[3]}`;
			})
			.replace(rules2, (...p: unknown[]) => {
				const spaceSize = 100 - (p[1].length + `<!--`.length + `-`.length);
				const insetLine = `<!--${`-`.repeat(spaceSize)}-->`;
				return `\n${p[1]}${insetLine}\n${p[1]}${p[2]}${p[3]}`;
			})
			.replace(rules3, (...p: unknown[]) => {
				const spaceSize = 100 - (p[1].length + `<!--`.length + `-`.length);
				const insetLine = `<!--${`-`.repeat(spaceSize)}-->`;
				return `\n${p[1]}${insetLine}\n${p[1]}${p[2]}${p[3]}`;
			})
			.replace(rules4, (...p: unknown[]) => {
				const spaceSize = 100 - (p[1].length + `<!--`.length + `-`.length);
				const insetLine = `<!--${`-`.repeat(spaceSize)}-->`;
				return `\n${p[1]}${insetLine}\n${p[1]}${p[2]}${p[3]}`;
			})
			.replace(rules5, (...p: unknown[]) => {
				const spaceSize = 100 - (p[1].length + `<!--`.length + `-`.length);
				const insetLine = `<!--${`-`.repeat(spaceSize)}-->`;
				return `\n${p[1]}${insetLine}\n${p[1]}${p[2]}${p[3]}`;
			})
			.replace(rules6, (...p: unknown[]) => {
				const spaceSize = 100 - (p[1].length + `<!--`.length + `-`.length);
				const insetLine = `<!--${`-`.repeat(spaceSize)}-->`;
				return `\n${p[1]}${insetLine}\n${p[1]}${p[2]}${p[3]}`;
			})
			.replace(rules7, (...p: unknown[]) => {
				const spaceSize = 100 - (p[1].length + `<!--`.length + `-`.length);
				const insetLine = `<!--${`-`.repeat(spaceSize)}-->`;
				return `\n${p[1]}${insetLine}\n${p[1]}${p[2]}${p[3]}`;
			})
			.replace(rules8, (...p: unknown[]) => {
				const spaceSize = 100 - (p[1].length + `<!--`.length + `-`.length);
				const insetLine = `<!--${`-`.repeat(spaceSize)}-->`;
				return `\n${p[1]}${insetLine}\n${p[1]}${p[2]}${p[3]}`;
			})
			.replace(rules9, (...p: unknown[]) => {
				const spaceSize = 100 - (p[1].length + `<!--`.length + `-`.length);
				const insetLine = `<!--${`-`.repeat(spaceSize)}-->`;
				return `\n${p[1]}${insetLine}\n${p[1]}${p[2]}${p[3]}`;
			})
			.value();

		logger(`debug`, `${fileExt}:insertLine - Y`);
		return finalResult;
	}
	catch (err: unknown) {
		logger(`error`, `${fileExt}:insertLine - ${(err as Error).message}`);
		return contentsParam;
	}
};

// 3. insertSpace ----------------------------------------------------------------------------------
export const insertSpace = async (
	contentsParam: string,
	fileExt: string
) => {
	try {
		const rules1 = (
			/(\s*)(\))(\s+)(;)/gm
		);
		const rules2 = (
			/(\s*)(@)(\s*)([\s\S]*?)(\s*)(\()/gm
		);
		const rules3 = (
			/(\s*?)(ception)(\{)/gm
		);

		const finalResult = lodash.chain(contentsParam)
			.replace(rules1, (...p: unknown[]) => (
				`${p[1]}${p[2]};`
			))
			.replace(rules2, (...p: unknown[]) => (
				`${p[1]}${p[2]}${p[4]} ${p[6]}`
			))
			.replace(rules3, (...p: unknown[]) => (
				`${p[2]} ${p[3]}`
			))
			.value();

		logger(`debug`, `${fileExt}:insertSpace - Y`);
		return finalResult;
	}
	catch (err: unknown) {
		logger(`error`, `${fileExt}:insertSpace - ${(err as Error).message}`);
		return contentsParam;
	}
};